/* Model of data stored in Howl.
 *
 * TODO: Use memcache
 * TODO: Document how keys are generated and used.
 * 
 * Copyright (C) Sarah Mount, 2011.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package model

import (
	"appengine"
    "appengine/datastore"
	"log"
	"os"
	"time"
)


const (
	max_streams					= 100
	max_providers				= 100
	max_shared_streams			= 100
	max_shared_providers		= 100
)


/* Return the current time since the UNIX epoch.
 */
func Now() datastore.Time {
	return datastore.SecondsToTime(time.Seconds())
}


/* Place an object in the datastore.
 * TODO: Use memcache.
 *
 * @param context for this particular appengine session
 * @param key datastore key for the object to be stored
 * @param error message to be printed to the log / user in case of error
 * @param object the object to be made persistent
 * @return the key returned by the persistent store (if there is one, nil otherwise) and an error report (if there is one, nil otherwise)
 */
func put(context appengine.Context, key *datastore.Key, error string, object interface{}) (*datastore.Key, os.Error) {
    key_, err := datastore.Put(context, key, object)
	if err != nil {
		log.Println(error + " " + err.String())
        return nil, err
    }
	return key_, nil
}


/* Place an entity in the datastore only if no entity with the same fields eists.
 * TODO: Use memcache.
 *
 * @param context for this particular appengine session
 * @param key datastore key for the object to be stored
 * @param error message to be printed to the log / user in case of error
 * @param object the object to be made persistent
 * @return the key returned by the persistent store (if there is one, nil other
 */
func putSingleton(context appengine.Context, key *datastore.Key, error string, object interface{}) (*datastore.Key, os.Error) {
	_, err_get := get(context, key, "", object)
	if err_get == nil { // Object is already in the store.
		return key, nil
	}
	return put(context, key, error, object)
}


/* Get an object from the datastore.
 * TODO: Use memcache.
 *
 * @param context for this particular appengine session
 * @param key datastore key for the object to be retrieved
 * @param object the object to be made persistent
 * @param error message to be printed to the log / user in case of error
 * @return the retrieved object and any errors generated by the datastore
 */
func get(context appengine.Context, key *datastore.Key, error string, object interface{}) (interface{}, os.Error) {
	err := datastore.Get(context, key, object)
	if err != nil {
		log.Println(error + err.String())		
		return nil, err
	} 
	return object, nil
}


/* Query the datastore.
 * TODO: Use memcache.
 *
 * @param context for this particular appengine session
 * @param key datastore key for the object to be retrieved
 * @param object the object to be made persistent
 * @param error message to be printed to the log / user in case of error
 * @return a list of keys returned by the query and errors generated by the query (if there are any)
 */
func query(context appengine.Context, query *datastore.Query, objects interface{}, error string) ([]*datastore.Key, os.Error) {
	keys, err := query.GetAll(context, objects)
	if err != nil {
		log.Println(error + err.String())		
		return nil, err
	} 
	return keys, nil
}


/* Delete an entity from the datastore.
 * TODO: Use memcache.
 *
 * @param context for this particular appengine session
 * @param key datastore key for the object to be deleted
 * @return any errors generated by the datastore
 */
func delete(context appengine.Context, key *datastore.Key) (os.Error) {
	err := datastore.Delete(context, key)
	return err
}


